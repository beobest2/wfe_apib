FORMAT: 1A
HOST: http://192.168.100.100/api/v1/

# WFE (Work Flow Engine)

- Workflow-Manager
    - 다수 또는 단일 workflow-engine을 관리
    - REST api가 연결되는 통합 관리 모듈
    - manager가 관리하는 데이터베이스
        - engine_db
            - engine_name | ip | port
        - flow_db
            - flow_name | engine_name | ip | port
        - group_db
            - group_name | tasks
- Workflow-Engine
    - 실제 task를 띄우고 flow를 관리하는 engine
    - engine이 관리하는 데이터베이스
        - config_db 
        - job_db
        - arrow_ab
        - flow_db
        - group_db
        - engine_db
        - task_db
- Job
    - flow를 특정 시간 주기로 실행하기 위해 crontab에 등록 [수정됨]
    - crontab 등록은 manager node에서만 되는지 flow가 있는 engine노드에 등록되는지 ?? [수정필요]
- Group
    - Task 집합
    - 각기 다른 engine의 task 끼리 등록 가능
- Flow
    - 프로세스와 프로세스를(Task) 연결하는 흐름
        - ex > flow : A(task) ->(arrow) B(task) ->(arrow) C(task)
    - flow는 task, arrow, job을 포함
- Task
    - 하나의 프로세스를 의미
    - 하나의 프로세스에서 하나 이상의 작업 수행 가능
    - 모든 프로그래밍 언어 지원
- Queue
    - Task간에 데이터가 공유되는 queue
    - 하나의 task는 input과 output 두가지의 queue를 가짐
    - 방향성 존재
- Arrow
    - task간의 데이터 연결 방식을 정의하는 단위
    - arrow는 1:1, 1:n 형태 지원
    - broad, shared 두 가지 타입을 가짐


## Engines [/engines]

### engine list 조회 - GET [GET]

- 등록된 engine을 목록으로 가져옴
    - WF-Manager 에 저장된 엔진 IP, Port, engine_name, id 정보
    - engine_name, engine_id는 전체 시스템에서 각각 unique
- CLI
    ```
    $wf engine list
    ```

+ Response 200 (application/json)

        
        {
                {
                    "IP_ADDR" : "192.168.100.11",
                    "PORT" : "5000",
                    "ENGINE_NAME": "test01",
                    "ENGINE_ID" : "e1",
                    "URL" : "~/engines/{engine_id}"
                },
                   
                {
                    "IP_ADDR" : "192.168.100.11",
                    "PORT" : "5002",
                    "ENGINE_NAME" : "test02",
                    "ENGINE_ID" : "e2",
                    "URL" : "~/engines/{engine_id}"
                },
                ...
        }

### engine 추가 - POST [POST]

- engine을 추가함
    - ip, port, engine_name을 파라메터로 전송 
    - manager에서 engine_id 생성하여 응답
    - 실제 엔진이 동작하는지 IP, Port, ENGINE_NAME 중복여부 체크 후 리스트에 추가
- CLI
    ```
    $wf engine add --engine_name {engine01} --ip {192.168.100.11} --port {3500}
    ``` 
+ Request (application/json)

        {
            "ENGINE_NAME" : "test_engine",
            "IP_ADDR": "192.168.100.21",
            "PORT" : "5050"
        }

        
+ Response 200 (application/json)

        {
            "RESULT" : "[OK|NOK]",
            "ENGINE_ID" : "e3",
            "MESSAGE" : "[MESSAGE_STRING | ERROR CODE]"           
        }

        
## Engine [/engines/{engine_id}]

### engine 상세정보 조회 - GET [GET]

- engine의 상세 정보 조회
- 데이터는 각 엔진에서 가져옴
- CLI
    ```
    $wf engine info --engine_name {engine01}
    ```
        
+ Response 200 (application/json)

        {
            "IP_ADDR": "192.168.100.21",
            "PORT" : "5050",
            "ENGINE_NAME" : "engine3",
            "ENGINE_ID": "e3",
            "STATUS" : "[VALID | INVALID | WAIT_RETRY]"
            "CPU": "23",
            "RAM" : "30",
            "DISK" : "11",
            "IO_WAIT" : "1"
        }

### engine 삭제 - DELETE [DELETE]

- engine을 삭제함
- CLI
    ```
    $wf engine del --engine_name {engine01}
    ``` 
        
+ Response 200 (application/json)

        {
            "RESULT" : "[OK | NOK]",
            "MESSAGE" : "[MESSAGE_STRING | ERROR CODE]"           
        }
        
## Engine statistic [/engines/{engine_id}/statistic]

### Engine 통계정보 조회 - GET [GET]

- Engine의 통계 정보를 받아옴 (global_queue)
- CLI
    ```
    $wf engine statistic --engine_name {engine01}
    ```
    
+ Response 200 (application/json)

        {
    
                * engine 통계 정보
                    변경 history, 실행 결과 history 등
            "CHANGE_HISTORY" : "",
            "RESULT_HISTORY" : "",
            ...
            
        }

            
## Configs [/configs]

### config 조회 - GET [GET]

- WFE의 전반적인 설정 사항을 목록으로 가져옴
- CHANGEABLE 옵션을 주어 변경 가능 or 변경 불가능 옵션별 조회 가능
- CLI
    ```
    $wf config list (--engine_name {engine01}) (--changeable [True|Flase])
    ```


+ Request optional (application/json)

        ** optional
        {
            ("ENGINE_NAME" : "engine_name"),
            ("CHANGEABLE" : "[TRUE|FALSE]")
        }
        
+ Response 200 (application/json)

        {

           {
               "KEY" : "[KEY_STRING]",
               "VALUE" : "[VALUE_STRING]",
               "CHANGEABLE" : "[True|False]"
           }
           ,
           ...
           
        }
        

### config 변경 - PUT [PUT]

- 저장된 설정 정보 변경
- CHANGEABLE이 TRUE인 설정만 변경 가능
- CLI
    ```
    $wf config change --key {key} --value {value}
    ```


+ Request (application/json)

           {
               "KEY" : "[변경하고자 하는 KEY]",
               "VALUE" : "[변경하고자 하는 VALUE]"
           }
        

+ Response 200 (application/json)

        
           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR CODE]"           
           }

        
 
## Jobs [/jobs]

### job list 조회 - GET [GET]

- 등록된 모든 job 목록 가져옴
- engine_name 옵션을 통해 해당 engine에 속한 JOB만 조회 가능
- CLI
    ```
    $wf job list (--engine_name {engine01})
    ```
    
+ Request (application/json)

        ** optional
        {
               ("ENGINE_NAME" : "engine1")
        }
        
+ Response 200 (application/json)

        {
           
               {
                   "ENGINE_NAME": "engine1",
                   "ENGINE_ID" : "e1",
                   "ENGINE_URL" : "~/engines/{engine_id}",
                   
                   "FLOW_NAME" : "flow01",
                   "FLOW_ID" : "f1",
                   "FLOW_URL" : "~/flows/{flow_id}"
                   
                   "JOB_NAME" : "etl_job01",
                   "JOB_ID" : "j1"
                   "JOB_URL" : "~/{flow_id}/jobs/{job_id}"
               },
               ...
               
        }

### job 생성 - POST [POST]

- job을 생성함, crontab에 등록됨
- job이 등록될 engine, flow, job_name, cron 시간 주기 입력
- CLI
    ```
    $wf job add --flow_name {flow01} --job_name {job01} --cron {*/1 * * * *}
    ```
    
+ Request (application/json)

        {
                "FLOW_NAME": "flow01",
                "JOB_NAME" : "job01",
                "CRON": "*/1 * * * *"
        }
        
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "JOB_ID" : "1"
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"
           }    

        
## Job [/{flow_id}/jobs/{job_id}]

### job 상세 정보 조회 - GET [GET]
- job 상세정보 조회
- CLI
    ```
    $wf job info --flow_name {flow01} --job_name {job01}
    ```
           
+ Response 200 (application/json)


           {
               "ENGINE_NAME": "engine1",
               "ENGINE_ID" : "e1",
               "ENGINE_URL" : "~/engines/{engine_id}",
               
               "FLOW_NAME" : "flow01",
               "FLOW_ID" : "f1",
               "FLOW_URL" : "~/flows/{flow_id}"
               
               "JOB_NAME" : "etl_job01",
               "JOB_ID" : "j1"
               "JOB_URL" : "~/{flow_id}/jobs/{job_id}"
               
               "CREATE_TIME": "20180707111111", 
               "UPDATE_TIME": "20180707111111",
               "LAST_EXECUTE_TIME": "20180707111122", 
               
               "STATE": "[ENABLE|DISABLE]",
               
               "TIME_FORMAT": "*/1 * * * *",
               "CALL_BACK_URL" : "192.168.123.123"
           }
           
### job 상태 변경 - PUT [PUT]
- job 설정 정보 변경
    - job 실행 주기를 변경한다
- CLI
    ```
    $wf job change --flow_name {flow01} --job_name {job01} --cron {*/10 * * * *}
    ```
    
+ Request (application/json)
           
        {
            "TIME_FORMAT": "*/10 * * * *"
        }
           
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"
           }  
        

### job 삭제 - DELETE [DELETE]

- 등록되어있는 job을 삭제함
- CLI
    ```
    $wf job del --flow_name {flow01} --job_name {job01}
    ```
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"
           } 

## Job control [/{flow_id}/jobs/{job_id}/control]


### Job 실행 제어 - PUT [PUT]

- job의 상태를 pause, resume 을 통해 "ACT", "TRM" 시킴 [동작 수정 필요]
- CLI
    ```
    $wf job control [pause|resume] --flow_name {flow01} --job_name {job01}
    ```
 
    
+ Request (application/json)

            {
               "CONTROL" : "[pause | resume]"
            }
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "STATUS" : "[ACT | ABN | TRM | ... ]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"
           } 

## Jobs statistic [/{flow_id}/jobs/{job_id}/statistic]

### Job 통계정보 조회 - GET [GET]

- Job 통계 정보를 받아옴
- CLI
    ```
    $wf job statistic --flow_name {flow01} --job_name {job01}
    ```
    
+ Response 200 (application/json)

        {
               "JOBS" : {
                * job 통계 정보
                생성자, 실행자, 변경 history, 실행 결과 history 등
               }
        }


## Groups [/groups]

### group 조회 - GET [GET]

- 등록된 group 목록을 받아옴
- group db는 중앙 manager 관리
- CLI
    ```
    $wf group list
    ```
+ Response 200 (application/json)

        {
               
                {
                    "GROUP_NAME" : "etl_group01",
                    "GROUP_ID" : "g1",
                    "GROUP_URL" : "~/groups/{group_id}"
                },
                {
                    "GROUP_NAME" : "parser_group",
                    "GROUP_ID" : "g2",
                    "GROUP_URL" : "~/groups/{group_id}"
                },
            ...
            ...
        }
  
### group 생성 - POST [POST]

- group을 생성함
    - group을 생성할 group_name, group에 속할 task목록 입력
    - task리스트는 {flow_name}.{task_name} 형태로서 어느 flow의 task인지 명시되어야 함
    - group_name 중복 불가
- group_id 반환
- CLI
    ```
    $wf group add --group_name {group01} --tasks {flow01.task1,flow01.task3}
    ```
   
+ Request (application/json)

        {
               "GROUP_NAME": "etl_group01",
               "tasks" : "flow01.task1,flow01.task3",
        }
        

+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "GROUP_ID" : "g1"
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }
    
## Group [/groups/{group_id}]

### group 상세 정보  조회 - GET [GET]
- group 상세 정보 조회
- CLI
    ```
    $wf group info --group_name {group01} 
    ```
+ Response 200 (application/json)


        {
            "GROUP_NAME" : "etl_group01",
            "GROUP_ID" : "g1",
            "GROUP_URL" : "~/groups/{group_id}"
            
            "TASKS" : [
                        {
                            "ENGINE_NAME" : "engine1",
                            "ENGINE_ID" : "e1",
                            "ENGINE_URL" : "~/engines/{engine_id}",
            
                            "FLOW_NAME" : "flow01",
                            "FLOW_ID" : "f1",
                            "FLOW_URL" : "~/flows/{flow_id}",
                            
                            "TASK_NAME" : "task01",
                            "TASK_ID" : "t1",
                            "TASK_URL" : "~/{flow_id}/tasks/{task_id}"
                        }
                        ,
                        {
                            "ENGINE_NAME" : "engine2",
                            "ENGINE_ID" : "e2",
                            "ENGINE_URL" : "~/engines/{engine_id}",
            
                            "FLOW_NAME" : "flow03",
                            "FLOW_ID" : "f3",
                            "FLOW_URL" : "~/flows/{flow_id}",
                            
                            "TASK_NAME" : "task01",
                            "TASK_ID" : "t1",
                            "TASK_URL" : "~/{flow_id}/tasks/{task_id}"
                        }
                    ...
                    ]
        }
        
### group 정보 변경 - PUT [PUT]
- group 정보 변경
- CLI
    ```
    $wf group change --group_name {group01} --key {key} --value {value}
    ```

+ Request (application/json)

        {
               {
                   * group 수정 사항
                   "KEY" : "[변경하고자 하는 KEY]",
                   "VALUE" : "[변경하고자 하는 VALUE]"
               }
        }
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }
           

### group 삭제 - DELETE [DELETE]
    
- group  둥록 정보 삭제
- CLI
    ```
    $wf group del --group_name {group01}
    ```
           
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }
        
## Group control [/groups/{group_id}/control]

### group 상태 변경 - PUT [PUT]

- group에 속한 모든  flow의 상태를 끄거나 킴
- CLI
    ```
    $wf group control [start|stop|pause|resume] --group_name {group01}
    ```
    
+ Request (application/json)
       
            {
                "CONTROL" : "[start|stop|pause|resume]"
            }
           
+ Response 200 (application/json)

           {
               "RESULT" : ["OK"|"NOK"],
               "STATUS" : "[수정필요]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }



## Flows [/flows]

### flow list 조회 - GET [GET]

- 등록된 flow 목록을 받아옴
- engine 정보를 옵션으로 주어 해당 engine의 flow 목록만 조회 가능
- CLI
    ```
    $wf flow list (--engine_name {engine01})
    ```
    

+ Request (application/json)

        ** optional
        {
                ("ENGINE_NAME" : "engine01")
        }
        
+ Response 200 (application/json)

        {
                {
                    "ENGINE_NAME": "engine1",
                    "ENGINE_ID" : "e1",
                    "ENGINE_URL" : "~/engines/{engine_id}",
                    
                    "FLOW_NAME": "happy_flow",
                    "FLOW_ID" : "f1",
                    "FLOW_URL" : "~/flows/{flow_id}"
                },
                {
                    "ENGINE_NAME": "engine1",
                    "ENGINE_ID" : "e1",
                    "ENGINE_URL" : "~/engines/{engine_id}",
                    
                    "FLOW_NAME": "good_flow",
                    "FLOW_ID" : "f2",
                    "FLOW_URL" : "~/flows/{flow_id}"
                },
            ...
        }

### flow 생성 - POST [POST]

- flow를 생성함
    - flow를 생성할 engine을 지정
    - flow_name을 입력하면 flow가 생성되고 flow_id반환
    - flow_name 중복 불가
- CLI
    ```
    $wf flow add --engine_name {engine01} --flow_name {flow01}
    ```
    

+ Request (application/json)

        {
                "ENGINE_NAME": "engine01",
                "FLOW_NAME": "flow01"
        }

+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "FLOW_ID" : "f2",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }


        
## Flow [/flows/{flow_id}]

### flow 상세 정보 조회 - GET [GET]
- flow 상세 정보 조회
- CLI
    ```
    $wf flow info --flow_name {flow01}
    ```


+ Response 200 (application/json)

        
        {
            "ENGINE_NAME": "engine1",
            "ENGINE_ID" : "e1",
            "ENGINE_URL" : "~/engines/{engine_id}",
            
            "FLOW_NAME": "happy_flow",
            "FLOW_ID" : "f1",
            "FLOW_URL" : "~/flows/{flow_id}",
            
            "FLOW_STATUS": "[standby | running | complete | warning]",
            "JOB_REGISTERED": "[True | False]",
            
            "FLOW_STRUCTURE" :
            {
                "TASKS" : [
                    taskA [task_level1],
                    taskB [task_level2],
                    taskC [task_level3],
                ],
                
                "ARROWS" : [
                    arrowA,
                    arrowB,
                ],
            },
            "CREATE_TIME": "20180707111111", 
            "UPDATE_TIME": 
            "LAST_EXECUTE_TIME":
            "START_TIME":
            "END_TIME":
        }
        
### flow 수정 - PUT [PUT]

- 해당 flow를 수정함
- 수정 가능 사항만 수정 가능
- CLI
    ```
    $wf flow change --flow_name {flow01} --key {key} --value {value}
    ```
    

+ Request (application/json)

           {
               * flow 수정 사항
               "KEY" : "[변경하고자 하는 KEY]",
               "VALUE" : "[변경하고자 하는 VALUE]"
           }

        
+ Response 200 (application/json)

           {
               "RESULT" : ["OK"|"NOK"],
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }
           
### flow 삭제 - DELETE [DELETE]

- 해당 flow 등록 정보를 삭제함
- flow에 속한 task와 arrow도 함께 삭제됨
- locking check
    - flow가 현재 동작중인지 체크
- CLI
    ```
    $wf flow del --flow_name {flow01}
    ```
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }


## Flow control [/flows/{flow_id}/control]

### flow 실행 제어 - PUT [PUT]

- CLI
    ```
    $wf flow control [start|stop|resume|pause] --flow_name {flow01}
    ```
    
    
+ Request (application/json)
        
            {
                 "CONTROL" : "[start|stop|resume|pause]"
            }
            
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "STATUS" : "[수정필요]"
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }


   
## Tasks [/tasks]

### task list 조회 - GET [GET]
- 등록된 Task 정보를 목록으로 가져옴
- 옵션을 통해 특정 키나 특정 엔진의 task 리스트만 조회 가능
- CLI
    ```
    $wf task list (--engine_name {engine01})
    ```
    
+ Request optional (application/json)

        ** optional
        {
            "ENGINE_NAME" : "engine01"
        }
        
+ Response 200 (application/json)

        {

           {
                "ENGINE_NAME" : "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "TASK_NAME" : "task01",
                "TASK_ID" : "t1",
                "TASK_URL" : "~/{flow_id}/tasks/{task_id}",
           },
           {
                "ENGINE_NAME" : "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "TASK_NAME" : "task02",
                "TASK_ID" : "t2",
                "TASK_URL" : "~/{flow_id}/tasks/{task_id}",
           },
           ...

        }
        

### Task 생성 - POST [POST]

- task를 생성함
    - 생성할 task의 engine, flow의 위치, task의 이름 지정
    - 생성된 task의 id 반환
- Task option에 daemon여부 설정 가능
    - Daemon인 경우 상시 동작하는 프로세스
- task name 은 같은 engine내에서는 중복 불가
- CLI
    ```
    $wf task add --flow_name {flow01} --task_name {task01} --command {“python test01.py arg1”} (--daemon [True|False]) (--description {"this is .."})
    ```

+ Request (application/json)

           {
                "FLOW_NAME" : "flow01",
                "TASK_NAME": "task01",
                "COMMAND": "python test01.py arg1",
                ("DAEMON" : "True" [수정필요:default는 무엇으로 할지]),
                ("DESCRIPTION": "this is parser")
           }
        
        
+ Response 200 (application/json)


           {
               "RESULT" : "[OK|NOK]",
               "TASK_ID" : "t1"
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }



## Task [/{flow_id}/tasks/{task_id}]

### task 상세 정보 조회 - GET [GET]
- task 상세 정보 조회
- CLI
    ```
    $wf task info --flow_name {flow01} --task_name {task01} 
    ```

+ Response 200 (application/json)


           {
                "ENGINE_NAME" : "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "TASK_NAME" : "TASK_NAME",
                "TASK_ID" : "t1",
                "TASK_URL" : "~/{flow_id}/tasks/{task_id}",
                
                "TASK_LEVEL" : "2",
                "DAEMON" : "[True | False]",
                "PID": "PID",
                "STATUS": "[ACTIVE | INACTIVE]",
                "JOB_REGISTERED": "[True | False]",
                
                "ACT-TIME" : "[ACT-TIME]",
                "ACT-STATUS" : "[ACT-STATUS]", 
                "ACT-COUNT" : "[ACT-COUNT]",
                "COMMAND" : "[COMMAND]",
                
                "CREATE_TIME": "20180707111111", 
                "UPDATE_TIME": "20180707111112", 
                "LAST_EXECUTE_TIME": "20180707111113", 
                "START_TIME": "20180707111113", 
                "END_TIME": "20180707111114", 
                
                "LAST-STATUS" : {
                   "LAST-STD-IN" : "[EVENT_DATA]",
                   "LAST-STD-OUT" : "[EVENT_DATA]",
                   "LAST-STD-ERR" : "[EVENT_DATA]"
                }
            }

        
        
### task 상세 정보 변경 - PUT [PUT]
- task의 상세 정보를 변경
- CLI
    ```
    $wf task change --flow_name {flow01} --task_name {task01} --key {key} --value {value}
    ```

+ Request (application/json)

        {
           {
               "KEY" : "DAEMON",
               "VALUE" : "False"
           },
           ...
        }

        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }


### task 삭제 - DELETE [DELETE]

- 등록된 Task 삭제
- locking check
    - 현재 task가 속한 flow가 동작중인지 확인
- CLI
    ```
    $wf task del --flow_name {flow01} --task_name {task01}
    ```

+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }

## Task control [/{flow_id}/tasks/{task_id}/control]


### task 제어 - PUT [PUT]

- task의 상태를 start|stop|resume|pause 을 통해 동작 제어
- CLI
    ```
    $wf task control [start|stop|resume|pause] --flow_name {flow01} --task_name {task01}
    ```
    
+ Request (application/json)

    
           {
               "CONTROL" : "[start|stop|resume|pause]"
           }
        
        
+ Response 200 (application/json)


           {
               "RESULT" : "[OK|NOK]",
               "STATUS" :: "[수정필요]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }


## Task resource [/{flow_id}/tasks/{task_id}/resource]

### task 기반 리소스 모니터링 - GET [GET]

- task 기반 리소스 모니터링
- CLI
    ```
    $wf task resource --flow_name {flow01} --task_name {task01}
    ```
    
+ Response 200 (application/json)

           {
                "ENGINE_NAME": "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "TASK_NAME" : "task01",
                "TASK_ID" : "t1",
                "TASK_URL" : "~/{flow_id}/tasks/{task_id}",
                
                "PID" : "1234",
                "CPU": "20",
                "MEMORY": "10",
                "DISK": "25",
                "NETWORK": "111"
           }
        


## Task queue [/{flow_id}/tasks/{task_id}/queue]

### queue 정보 받아옴 - GET [GET]

- 해당 task의 모든 queue 정보를 가져옴
- CLI
    ```
    $wf task queue --flow_name {flow01} --task_name {task01}
    ```
    
+ Response 200 (application/json)

           {
                "ENGINE_NAME": "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "TASK_NAME" : "task01",
                "TASK_ID" : "t1",
                "TASK_URL" : "~/{flow_id}/tasks/{task_id}",
                
                "TASK_QUEUE" : 
                    {
                        "TYPE" :
                            {
                            "BROADCASTING STDIN" : [
                               ...
                            ],
                            "SHARING STDIN" : [
                               ...
                            ],
                            "ERROR" : [
                               ...
                            ]
                        }
                    }
           }

### queue에 데이터를 넣음 - PUT [PUT]
    
- 해당 task의 stdin queue에 데이터를 넣음
- CLI
    ```
    $wf task queue put --flow_name {flow01} --task_name {task01} --type {shared} --data {data}
    ```

+ Request (application/json)

        {
               "TYPE" : "[BROADCASTSHARED]" [수정필요: input ? output?],
               "DATA" : "data"
        }
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }

## Arrows [/arrows]

### arrow list 조회 - GET [GET]

- 등록된 arrow의 목록 조회
- engine 정보를 옵션으로 주어 해당 engine의 arrow 목록만 조회 가능
- CLI
    ```
    $wf arrow list (--engine_name {engine01})
    ```

+ Request optional (application/json)

        ** optional
        {
                ("ENGINE_NAME" : "engine1")
        }
        
+ Response 200 (application/json)

        
        {
            {
                "ENGINE_NAME": "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "ARROW_NAME" : "ARROW_NAME",
                "ARROW_ID" : "a1",
                "ARROW_URL" : "~/{flow_id}/arrows/{arrow_id}"
            },
             {
                "ENGINE_NAME": "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "ARROW_NAME" : "ARROW_NAME",
                "ARROW_ID" : "a2",
                "ARROW_URL" : "~/{flow_id}/arrows/{arrow_id}"
            },
            ...
        }

### arrow 등록 - POST [POST]

- 새로운 arrow를 등록함
    - arrow를 등록할 engine, flow와 arrow 정보를 함께 입력
    - arrow id 반환
- CLI
    ```
    $wf arrow add --flow_name {flow01} --arrow_name {arrow01} --type {shared} --arrow {task01|task02, task03}
    ```

+ Request (application/json)

        {
                "FLOW_NAME" : "flow01",
                "ARROW_NAME": "arrow01",
                
                "TYPE": "[SHARED | BROAD]", 
                "ARROW": "task01 | task02, task03"    
        }
        
+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "ARROW_ID": "5", 
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }
        
        
## Arrow [/{flow_id}/arrows/{arrow_id}]


### arrow 상세 정보 조회 - GET [GET]
- arrow 상세 정보 조회
- CLI
    ```
    $wf arrow info --flow_name {flow01} --arrow_name {arrow01}
    ```
+ Response 200 (application/json)


            {
                "ENGINE_NAME": "engine01",
                "ENGINE_ID" : "e1",
                "ENGINE_URL" : "~/engines/{engine_id}",
                
                "FLOW_NAME" : "flow01",
                "FLOW_ID" : "f1",
                "FLOW_URL" : "~/flows/{flow_id}",
                
                "ARROW_NAME" : "ARROW_NAME",
                "ARROW_ID" : "a1",
                "ARROW_URL" : "~/{flow_id}/arrows/{arrow_id}"
            
                "TYPE":
                {
                
                   "BROAD" : [ 
                       {
                           "FROM" : "[TASK]",
                           "TO" : "[TASK]"
                       },
                       ...
                   ],
                   "SHARED" : [ 
                       {
                           "FROM" : "[TASK]",
                           "TO" : "[TASK]"
                       },
                       ...
                   ]
                }
            }



### arrow 정보 수정 - PUT [PUT]
- 해당 arrow를 수정함
- 수정 가능 사항만 수정 가능
- CLI
    ```
    $wf arrow change --flow_name {flow01} --arrow_name {arrow01} --key {type} --value {broad}
    ```

+ Request (application/json)

           {
               * arrow 수정 사항
               "KEY" : "TYPE",
               "VALUE" : "BROAD"
           }
        

+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }
           
### arrow 삭제 - DELETE [DELETE]


- locking check
    - 현재 arrow가 속한 flow가 동작중인지 확인
- CLI
    ```
    $wf arrow del --flow_name {flow01} --arrow_name {arrow01}
    ```

+ Response 200 (application/json)

           {
               "RESULT" : "[OK|NOK]",
               "MESSAGE" : "[MESSAGE_STRING | ERROR_CODE]"             
           }